

# This file was *autogenerated* from the file UsefulFunctions.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2)
import itertools

def pause():
    input("\n(Press ENTER to continue and CTR+C to stop)")
    return

#___________________________________________________
# Functions in number theory:

# function splits the positive integer n into two positive integers n' and m such that gcd(n',q)=1 and rad(m)|q
# where q=p^l is a prime power
def make_gcd_one(q,n):
    p=((q.factor())[_sage_const_0 ])[_sage_const_0 ]
    l=n.valuation(p)
    return (int(n/p**l), p**l)

# function checks whether a given integer is a prime power
def is_prime_power(q):
    if q==_sage_const_0 :
        return False
    else:
        if len(factor(q))==_sage_const_1 :
            return True
        else: 
            return False
    return 

# function returns the radical of a positive integer n:
def rad(n):
    return  prod([fac[_sage_const_0 ] for fac in factor(n)])

# function returns the p-adic valuation of integer n for prime p
# Info: Use n.valuation(p) instead! 
#def nu(p,n):
#    return n.valuation(p)

# function returns all k-subsets of the set s:
def k_subsets(s,k):
    return set(itertools.combinations(s,k))

# This function returns the cyclotomic coset of i mod d over Fq
def cycl_coset(q,d,i):
    return [i*q**j % d for j in range((Mod(q,d/(gcd(d,i))).multiplicative_order()))]

# This function returns a representative system for the q-cyclotomic classes modulo d
def cycl_coset_repsystem(q,d):
    if d==_sage_const_1 :
        coset_reps = {_sage_const_0 }
    elif d>_sage_const_1 :            
        coset_reps = set()
        tbd = list(range(_sage_const_0 ,d))
        while len(tbd)>_sage_const_0 :
            i = tbd[_sage_const_0 ]
            coset_reps.add(i)
            tbd.remove(i)
            cyclel = i*q % d 

            while not cyclel == i:
                tbd.remove(cyclel)
                cyclel = cyclel*q % d 
    return coset_reps

#___________________________________________________
# Functions in finite fields:

# inverse function on a finite field
def inverse(a,F):
    return a**(F.cardinality()-_sage_const_2 )

#___________________________________________________
# Functions for polynomials:

# f(X^n) for f given as a list:
def composition_Xn(f,x, n):
    k=len(f)
    return sum([f[i]*x**(n*(k-_sage_const_1 -i)) for i in range(k)])

# function computes the q-spin of a given polynomial pol in the variable x
# coefficient degree is already given as cd 
def spin(q,x,pol,cd):
    poll = pol.list()
    spin = pol
    for j in range(_sage_const_1 ,cd):
        spin = spin * sum([poll[i]**(q**j)*x**i for i in range(len(poll))])
    return spin 

# function computes the q-spin of a binomial X^t-b given as (x,t,b)
# coefficient degree is already given as cd 
def spin_binomial(q,x,t,b,cd):
    spin =_sage_const_0 
    for i in range(cd+_sage_const_1 ):
        bproduct = sum([prod([b**(q**j) for j in J]) for J in k_subsets(range(cd),cd-i)])
        spin = spin+x**(t*i)*(-_sage_const_1 )**(cd-i)*bproduct
    return spin

# function casts polynomial in X^d to the basefield of REF
def pol_inXd_to_basefield(pol, REF, x, d):
    pol = pol.list()
    pol = [pol[l] for l in range(len(pol)) if l%d ==_sage_const_0 ]
    pol = sum(REF.to_basef(pol[l])*x**(d*l) for l in range(len(pol)))
    return pol  


# function computes the q-spin of the linear factor X-b given as x,b
# with the explicit formula based on k-subsets
# coefficient degree is already given as cd
def spin_linear_factor_explicit(q,x,b,cd):
    spin =_sage_const_0 
    for i in range(cd+_sage_const_1 ):
        bproduct = sum([prod([b**(q**j) for j in J]) for J in k_subsets(range(cd),cd-i)])
        spin = spin+x**(i)*(-_sage_const_1 )**(cd-i)*bproduct
    return spin

# functions prints the factorization as Magma does
def print_magma_style(factrztn):
    print(str_magma_style(factrztn))
    return

# function returns a string of a Factorization object in Magma-style
def str_magma_style(factrztn):
    return "\t"+"\n\t".join(["<"+str(fact[_sage_const_0 ])+","+str(fact[_sage_const_1 ])+">" for fact in factrztn])

# function returns a string of a polynomial for use with LaTeX:
def latex_pol(f,x):
    f=f.list()
    s=""
    for i in range(len(f)):
        if not f[i]==_sage_const_0 :
            if not f[i]==_sage_const_1 :
                sn = str(f[i])
            else:
                sn =""

            if not i in [_sage_const_0 ,_sage_const_1 ]:
                sn=sn+x+"^{"+str(i)+"}"
            if i==_sage_const_0 :
                if f[i]==_sage_const_1 :
                    sn = str(f[i])
            if i ==_sage_const_1 :
                sn = sn+x
                
            if len(s)>_sage_const_0 :
                s=sn+"+"+s
            else:
                s=sn
    return s



